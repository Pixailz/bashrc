#!/bin/bash

: ' parse_short
    parse space separated and option separated
'
function	parse_short()
{
	local	to_shift=0

	PARSED_ARG=()
	shift
	for item in ${*}; do
		is_option ${item}
		[ ${?} != 0 ] && break
		PARSED_ARG[${#PARSED_ARG[@]}]=${item}
	done
	return ${#PARSED_ARG[@]}
}

function	debug_print_parse_arg()
{
	debug_print_var 'FORCE_INSTALL' 1
	debug_print_array 'DO_PART' ${DO_PART[*]}
}

function	post_parsing()
{
	local	is_good

	if [ "${HAVE_PART}" != "" ] && [ ${#DO_PART[@]} == 0 ]; then
		p_warn "wrong usage. see --help"
		usage
	fi
	for to_str in ${DO_PART[*]}; do
		is_good=0
		for from_str in ${MODULE[*]}; do
			if [ ${to_str} == ${from_str} ]; then
				is_good=1
				break
			fi
		done
		if [ ${is_good} != 1 ]; then
			p_warn "wrong ${green}part name${reset} ${red}${to_str}${reset}"
			usage
		fi
	done
}

# pars args, keep parsing even if launch modules
## if -f, --force				set FORCE_INSTALL=1
## if -n, --no-color			disable_color
## if -h, --help				help

## if -p, --part				set DO_PART=part1 ... partn

## -p && -a						false
## -f|-n && -p | --part | -all		true
function	parse_arg()
{
	while [ "${1}" != "" ]; do
		case ${1} in
			-f|--force)
				export FORCE_INSTALL=1
				;;
			-h|--help)
				usage
				;;
			-p|--part)
				parse_short ${*}
				shift $?
				DO_PART=${PARSED_ARG[*]}
				HAVE_PART=1
				;;
			-n|--no-color)
				p_remove_colors
				;;
			*)
				p_warn "Wrongs options ${red}[${reset}${1}${red}]${reset}"
				usage
				;;
		esac
		shift
	done
	post_parsing
	# debug_print_parse_arg
}
