#!/bin/bash

: ' install_module MODULE
    install_file        install file to source
    install_func        entry func of module
    post_install_func   post install func of module
'
function	install_module()
{
	local	install_file="${DIR_MODULE}/${module}/install"
	local	install_func="${PREFIX_INSTALL_MODULE}${module}"
	local	post_install_func="${PREFIX_POST_INSTALL_MODULE}${module}"

	# source each module install file
	source ${install_file}
	${install_func}
	if [ "$(type -t ${post_install_func})" == "function" ]; then
		${post_install_func}
	fi
}

: ' install function for all modules
    DO_MODULE : specific array to do
    if len DO_MODULE == 0 do all
'
function	install_modules()
{
	if [ ${#DO_MODULE[*]} == 0 ]; then
		DO_MODULE=(${MODULE[@]})
		for module in ${INGORED_MODULE[@]}; do
			DO_MODULE=(${DO_MODULE[@]//${module}})
		done
	fi
	for module in ${DO_MODULE[*]}; do
		install_module
	done
}

function	main_entry()
{
	install_modules
}

# print help and quit
function	usage()
{
	printf "Usage : ${0} [-f|-n] [-p PART1... PARTN]\n"
	printf "  -f, --force       to force install\n"
	printf "  -n, --no-color    to disable colors\n"
	printf "  -l, --no-log      to disable the log"
	printf "  -h, --help        show this help\n"
	#printf "  -u, --user        install for specified user, default to current"
	#TODO
	printf "\n"
	printf "  -p, --part        install part, available part:\n"
	printf "                        - bash\n"
	printf "                        - batcat\n"
	printf "                        - gdb\n"
	printf "                        - vim\n"
	printf "                    should be at the end of command\n"
	exit
}

function	git::check_update()
{
	local	latest_branch
	local	latest_branch_id
	local	latest_branch_name
	local	current_branch
	local	current_branch_id
	local	current_branch_name
	local	current_branch_short7

	cd ${HOME}/.local/bin/dot_files
	latest_branch=$(git --no-pager branch -r --sort='committerdate' --format='%(objectname) %(refname:lstrip=-1)' | tail -1)
	latest_branch_id=$(cut -d" " -f1 <<<${latest_branch})
	latest_branch_name=$(cut -d" " -f2 <<<${latest_branch})
	current_branch=$(git --no-pager branch --sort='committerdate' --format='%(objectname) %(refname:lstrip=-1)' | tail -1)
	current_branch_id=$(cut -d" " -f1 <<<${latest_branch})
	current_branch_id7=$(cut -c-7 <<<${current_branch_id})
	current_branch_name=$(cut -d" " -f2 <<<${latest_branch})
	if [ "${current_branch_id}" == "${latest_branch_id}" ]; then
		p_info "Already up-to-date (${current_branch_id7})"
	else
		p_warn "Not up-to-date"
		if [ "${current_branch_name}" != "${latest_branch_name}" ]; then
			p_warn "The Latest commit is comming from an another branches"
			p_info "switching to it"
			git reset --hard "${latest_branch_name}"
		else
			p_info "Pulling repo"
			git reset --hard HEAD && git pull
		fi
	fi
	cd - 1>/dev/null
}

PATH_CONFIG=$(realpath ${BASH_SOURCE[0]})
DIR_BASE=${PATH_CONFIG%/*}

# source .config
source ${DIR_BASE}/.config

git::check_update

parse_arg ${*}

# if not sourced, BASH_SOURCE keep current file when $0 keep launched file
if [ "${BASH_SOURCE[0]}" -ef "${0}" ]; then
	main_entry
fi
