#!/bin/bash

function	module::install()
{
	local	module="${1}"
	local	install_file="${DIR_MODULE}/${module}/install"
	local	tmp_func

	# source module install file
	source "${install_file}"
	for prefix in ${PREFIX_INSTALL_MODULE[@]}; do
		tmp_func="${prefix}::${module}"
		if [ "$(type -t ${tmp_func})" == "function" ]; then
			${tmp_func}
		fi
	done
}

: ' install function for all modules
    DO_MODULE : specific array to do
    if len DO_MODULE == 0 do all
'
function	modules::install()
{
	if [ "${#DO_MODULE[@]}" == 0 ]; then
		DO_MODULE=(${MODULE[@]})
		for module in ${INGORED_MODULE[@]}; do
			DO_MODULE=(${DO_MODULE[@]//${module}})
		done
	fi
	for module in ${DO_MODULE[*]}; do
		# log::main_title "${G}${module}${RST}" 1 "${O}"
		log::main_title "${G}${module}${RST}" 1 "${O}"
		module::install "${module}"
		printf "\x0a"
	done
}

function	dot::update()
{
	log::main_title "${G}Checking update${RST}" 1 "${LC}" 1
	utils::update_repo "https://github.com/Pixailz/dot_files" "${INSTALL_DIR}"
	utils::update_repo "https://github.com/Pixailz/lib_bash" "${DIR_LIB_BASH%\/*}"
}

# print help and quit
function	usage()
{
	# opt_usage
	printf "%b: ${SCRIPT_NAME} " "${P_USAGE}"
	printf "[-f|-n] [-p PART1... PARTN]\n"
	# desc
	printf "\tscripts to manage openvpn server docker\n"

	printf "\n\t1. Base\n"
	printf "\t\tflag available everywhere\n"
	parse::print_usage "h" "help" "Display the help then exit."
	parse::print_usage "" "version" "Display the version then exit."
	parse::print_usage "" "no-color" "disable all color"
	parse::print_usage "f" "force" "To force install"
	parse::print_usage "u" "update" "Update this script and lib_bash"
	parse::print_usage "p" "part" "install part, available part:"
	for part in ${MODULE[@]}; do
		parse::print_usage "" "" "    - ${part}"
	done
	parse::print_usage "" "" "should be at the end of command"
	printf "\n"
	parse::print_infos

	#printf "  -u, --user        install for specified user, default to current"
	#TODO
}

function	is::option()
{
	local	options_str=${1}

	if [[ ${options_str} =~ --.* ]]; then
		return 1
	elif [[ ${options_str} =~ -.* ]]; then
		return 2
	else
		return 0
	fi
}

: ' parse::short
    parse space separated and option separated
'
function	parse::short()
{
	local	to_shift=0

	PARSED_ARG=()
	shift
	for item in ${*}; do
		is::option ${item}
		[ ${?} != 0 ] && break
		PARSED_ARG[${#PARSED_ARG[@]}]=${item}
	done
	return ${#PARSED_ARG[@]}
}

function	parse::post_parsing()
{
	local	is_good

	if [ "${HAVE_PART}" == "1" ] && [ "${#DO_MODULE[@]}" == 0 ]; then
		print::warn "wrong usage. see --help"
		usage
	fi
	for to_str in ${DO_MODULE[@]}; do
		is_good=0
		for from_str in "${MODULE[@]}"; do
			if [ "${to_str}" == "${from_str}" ]; then
				is_good=1
				break
			fi
		done
		if [ "${is_good}" != 1 ]; then
			print::warn "wrong ${G}part name${RST} ${R}${to_str}${RST}"
			usage
		fi
	done
}

# pars args, keep parsing even if launch modules
## if -f, --force				set FORCE_INSTALL=1
## if -n, --no-color			disable_color
## if -h, --help				help

## if -p, --part				set DO_MODULE=part1 ... partn

## -p && -a						false
## -f|-n && -p | --part | -all		true
function	parse::arg()
{
	HAVE_PART=0
	DO_MODULE=()

	while [ "${1:-}" != "" ]; do
		case "${1}" in
			-f|--force)
				export FORCE_MOVE=1
				;;
			-h|--help)
				usage
				exit
				;;
			-p|--part)
				parse::short ${*}
				shift $?
				DO_MODULE=${PARSED_ARG[*]}
				HAVE_PART=1
				;;
			-n|--no-color)
				NO_ANSI=1
				ansi::toggle_color
				;;
			-u|--update)
				dot::update
				exit
				;;
			-l|--no-log)
				DONT_PRINT=1
				;;
			*)
				print::warn "wrong options ${R}[${RST}${1}${R}]${RST}"
				usage
				exit
				;;
		esac
		shift
	done
	parse::post_parsing
}

## source lib_bash
DIR_LIB_BASH="${HOME}/.local/lib/lib_bash"
[ ! -d "${HOME}/.local/lib" ] && mkdir -p "${HOME}/.local/lib"
if [ ! -d "${DIR_LIB_BASH}" ]; then
	printf "lib bash is not installed installing it.\n"
	git clone https://github.com/Pixailz/lib_bash "${DIR_LIB_BASH}"
fi

source "${DIR_LIB_BASH}/.config"

# source .config
PATH_CONFIG=$(realpath ${BASH_SOURCE[0]})
DIR_BASE=${PATH_CONFIG%/*}
source ${DIR_BASE}/.config

parse::arg ${*}

# if not sourced, BASH_SOURCE keep current file when $0 keep launched file
[ "${BASH_SOURCE[0]}" -ef "${0}" ] && modules::install
