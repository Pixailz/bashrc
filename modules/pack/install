#!/bin/bash

function curl::wrap()
{
	dry::run curl --location --progress-bar "${1}" --output "${2}"
}

function	install::uni::pip3()
{
	dry::run pip install --upgrade --break-system-packages pip setuptools
	dry::run pip install --upgrade --break-system-packages pwn
}

function	install::unit::script()
{
	local	link="${1?}"

	curl::wrap "${link}" ./tmp.sh
	dry::run chmod +x ./tmp.sh
	dry::run ./tmp.sh
	dry::run rm -rf ./tmp.sh
}

function	install::uni::with_link()
{
	if [ ! -f "${HOME}/BurpSuiteCommunity/BurpSuiteCommunity" ]; then
		print::info "Installing BurpSuite"
		install::unit::script "${UNI_LINK["burpsuite"]}"
	fi
	if [ ! -f "${HOME}/.gdbinit-gef.py" ]; then
		print::info "Installing GEF"
		curl::wrap "${UNI_LINK["gef"]}" "${HOME}/.gdbinit-gef.py"
		dry::run echo source ~/.gdbinit-gef.py >> ~/.gdbinit
	fi
	if [ ! -d /usr/share/wordlists ]; then
		print::info "/usr/share/wordlists not found, donwloading SecList"
		sudo git clone "${SECLISTS}" /usr/share/wordlists
	fi
}

function	install::deb::add_deb()
{
	local	target="${1?}"

	if [ ! -x "$(type -P ${target})" ]; then
		print::info "Downloading ${target}"
		curl::wrap "${DEB_LINK[${target}]}" "${target}.deb"
		to_install+=("${target}.deb")
	fi
}

function	install::deb::with_link()
{
	unset to_install
	declare -ga	to_install=()

	install::deb::add_deb google-chrome
	install::deb::add_deb code
	install::deb::add_deb java
	install::deb::add_deb delta

	if [ "${#to_install[@]}" == "0" ]; then
		print::info "Nothing to install"
	else
		print::info "Installing (apt:link)"
		printf -- "- %s\n" ${to_install[@]}
		dry::run sudo apt update
		dry::run sudo apt install -y ${to_install[@]}
	fi

	unset to_install
}

function	install::uni()
{
	install::uni::pip3
	install::uni::with_link
}

function	clean::package()
{
	declare	-a packages=(${@?})
	unset PARSED_PACK
	declare	-ag PARSED_PACK=()

	for package in ${packages[@]}; do
		[ ! -x "$(type -P ${package})" ] && PARSED_PACK+=(${package})
	done
}

function	install::deb()
{
	clean::package ${DEB_PACK[@]}
	if [ "${#PARSED_PACK[@]}" == "0" ]; then
		print::info "Nothing to install"
	else
		print::info "Installing (apt:name)"
		printf -- "- %s\n" ${PARSED_PACK[@]}
		dry::run sudo apt update && dry::run sudo apt install -y ${PARSED_PACK[@]}
	fi
	install::deb::with_link
}

function	configure::pacman()
{
	local	target="${1:-/etc/pacman.conf}"

	# activate parallel downloads
	sed -i 's/#ParallelDownloads.*/ParallelDownloads = 3/g' "${target}"
	# activate color
	sed -i "s/#Color/Color/" "${target}"
	# best option ever
	sed -i "38 i ILoveCandy" "${target}"
}

function	install::arch()
{
	clean::package ${ARCH_PAC_PACK[@]}
	configure::pacman
	if [ "${#PARSED_PACK[@]}" == "0" ]; then
		print::info "Nothing to install"
	else
		print::info "Installing (pac)"
		printf -- "- %s\n" ${PARSED_PACK[@]}
		dry::run sudo pacman -Syu --noconfirm ${PARSED_PACK[@]}
	fi
	if [ ! -x "$(type -P yay)" ]; then
		dry::run git clone https://aur.archlinux.org/yay /tmp/yay
		dry::run cd /tmp/yay
		dry::run makepkg -si --noconfirm
		dry::run cd -
		dry::run rm -rf /tmp/yay
	fi
	clean::package ${ARCH_YAY_PACK[@]}
	if [ "${#PARSED_PACK[@]}" == "0" ]; then
		print::info "Nothing to install"
	else
		print::info "Installing (yay)"
		printf -- "- %s\n" ${PARSED_PACK[@]}
		dry::run yay -Syu --noconfirm ${PARSED_PACK[@]}
	fi
}


# BINDED FUNCTION
function	post::install::pack()
{
	[ -f "${HOME}/.local/bin" ] && dry::run rm -f "${HOME}/.local/bin"
	[ ! -d "${HOME}/.local/bin" ] && dry::run mkdir -p "${HOME}/.local/bin"
}

function	install::pack()
{
	install::uni
	case ${OS_ID} in
		"ubuntu"|"debian"|"kali") install::deb ;;
		"arch") install::arch ;;
		*) print::warn "Not supported yet."
	esac
}

# if not sourced, BASH_SOURCE keep current file when $0 keep launched file
if [ "${BASH_SOURCE[0]}" -ef "${0}" ]; then
	if [ "${0}" -ef "install" ]; then
		source ../../dot
	elif [ "${0}" -ef "pack/install" ]; then
		source ../dot
	else
		source ./dot
	fi
	install::pack
fi
